"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const coc_nvim_1 = require("coc.nvim");
const vscode_uri_1 = tslib_1.__importDefault(require("vscode-uri"));
const glob_1 = tslib_1.__importDefault(require("glob"));
const workspaceDiscovery_1 = require("./workspaceDiscovery");
const sections = ["php"];
function activate(context) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let { subscriptions } = context;
        let c = coc_nvim_1.workspace.getConfiguration();
        const config = c.get("phpls");
        const enable = config.enable;
        const file = require.resolve("intelephense-server");
        if (enable === false)
            return;
        if (!file) {
            coc_nvim_1.workspace.showMessage("intelephense-server not found!, please run yarn global add intelephense-server", "error");
            return;
        }
        const selector = [
            {
                language: "php",
                scheme: "file"
            }
        ];
        let serverOptions = {
            module: file,
            args: ["--node-ipc"],
            transport: coc_nvim_1.TransportKind.ipc,
            options: {
                cwd: coc_nvim_1.workspace.root,
                execArgv: config.execArgv || []
            }
        };
        let fsWatcher = coc_nvim_1.workspace.createFileSystemWatcher("**/*.php", true, false, true);
        let clientOptions = {
            documentSelector: selector,
            synchronize: {
                configurationSection: sections,
                fileEvents: fsWatcher
            },
            outputChannelName: "php",
            initializationOptions: {},
            middleware: {
                provideCompletionItem: (document, position, context, token, next) => {
                    return Promise.resolve(next(document, position, context, token)).then((res) => {
                        let doc = coc_nvim_1.workspace.getDocument(document.uri);
                        if (!doc)
                            return [];
                        if (res.hasOwnProperty('isIncomplete')) {
                            let itemList = res;
                            itemList.items.forEach(fixItem);
                            return itemList;
                        }
                        let items = res;
                        items.forEach(fixItem);
                        return items;
                    });
                }
            }
        };
        let client = new coc_nvim_1.LanguageClient("phpls", "PHP Language Server", serverOptions, clientOptions);
        subscriptions.push(coc_nvim_1.services.registLanguageClient(client));
        client.onReady().then(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
            workspaceDiscovery_1.WorkspaceDiscovery.client = client;
            fsWatcher.onDidDelete(onDidDelete);
            fsWatcher.onDidCreate(onDidCreate);
            fsWatcher.onDidChange(onDidChange);
            let startedTime;
            return yield readAllFile(coc_nvim_1.workspace.rootPath)
                .then(files => files.map(file => vscode_uri_1.default.file(file)))
                .then(uriArray => {
                let token;
                coc_nvim_1.workspace.showMessage("Indexing started.");
                startedTime = new Date();
                return workspaceDiscovery_1.WorkspaceDiscovery.checkCacheThenDiscover(uriArray, true, token);
            })
                .then(() => {
                let usedTime = Math.abs(new Date().getTime() - startedTime.getTime());
                coc_nvim_1.workspace.showMessage("Indexed php files, times: " + usedTime + "ms");
            });
        }));
    });
}
exports.activate = activate;
function onDidDelete(uri) {
    workspaceDiscovery_1.WorkspaceDiscovery.forget(uri);
}
function onDidChange(uri) {
    workspaceDiscovery_1.WorkspaceDiscovery.delayedDiscover(uri);
}
function onDidCreate(uri) {
    onDidChange(uri);
}
function readAllFile(root) {
    return new Promise((resolve, reject) => {
        glob_1.default(root + "/**/*.php", (err, matches) => {
            if (err == null) {
                resolve(matches);
            }
            reject(err);
        });
    });
}
function fixItem(item) {
    if (/^\\\w+/.test(item.insertText) && !/^(\\\w+){2,}/.test(item.insertText)) {
        item.insertText = item.insertText.replace('\\', '');
    }
}
//# sourceMappingURL=index.js.map