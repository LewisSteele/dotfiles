"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const coc_nvim_1 = require("coc.nvim");
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const vscode_jsonrpc_1 = require("vscode-jsonrpc");
const schema_contributor_1 = require("./schema-contributor");
const vscode_uri_1 = tslib_1.__importDefault(require("vscode-uri"));
var SchemaAssociationNotification;
(function (SchemaAssociationNotification) {
    SchemaAssociationNotification.type = new vscode_jsonrpc_1.NotificationType('json/schemaAssociations');
})(SchemaAssociationNotification || (SchemaAssociationNotification = {}));
var DynamicCustomSchemaRequestRegistration;
(function (DynamicCustomSchemaRequestRegistration) {
    DynamicCustomSchemaRequestRegistration.type = new vscode_jsonrpc_1.NotificationType('yaml/registerCustomSchemaRequest');
})(DynamicCustomSchemaRequestRegistration || (DynamicCustomSchemaRequestRegistration = {}));
function activate(context) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let { subscriptions } = context;
        const config = coc_nvim_1.workspace.getConfiguration('NAME');
        let file = context.asAbsolutePath(path_1.default.join('node_modules', 'yaml-language-server', 'out', 'server', 'src', 'server.js'));
        if (!fs_1.default.existsSync(file)) {
            file = context.asAbsolutePath(path_1.default.join('..', 'yaml-language-server', 'out', 'server', 'src', 'server.js'));
        }
        if (!fs_1.default.existsSync(file)) {
            coc_nvim_1.workspace.showMessage(`Can't resolve yarml-language-server`, 'error');
            return;
        }
        let serverOptions = {
            module: file,
            args: ['--node-ipc'],
            transport: coc_nvim_1.TransportKind.ipc,
            options: {
                cwd: coc_nvim_1.workspace.root,
                execArgv: config.get('execArgv', [])
            }
        };
        let clientOptions = {
            documentSelector: [
                { language: 'yaml', scheme: 'file' },
                { language: 'yaml', scheme: 'untitled' }
            ],
            synchronize: {
                // Synchronize the setting section 'languageServerExample' to the server
                configurationSection: ['yaml', 'http.proxy', 'http.proxyStrictSSL'],
                // Notify the server about file changes to '.clientrc files contain in the workspace
                fileEvents: [
                    coc_nvim_1.workspace.createFileSystemWatcher('**/*.?(e)y?(a)ml'),
                    coc_nvim_1.workspace.createFileSystemWatcher('**/*.json')
                ]
            },
            outputChannelName: 'yaml'
        };
        let client = new coc_nvim_1.LanguageClient('yaml', 'yaml server', serverOptions, clientOptions);
        client.onReady().then(() => {
            client.sendNotification(SchemaAssociationNotification.type, getSchemaAssociation(context));
            client.sendNotification(DynamicCustomSchemaRequestRegistration.type);
            client.onRequest(schema_contributor_1.CUSTOM_SCHEMA_REQUEST, (resource) => {
                return schema_contributor_1.schemaContributor.requestCustomSchema(resource);
            });
            client.onRequest(schema_contributor_1.CUSTOM_CONTENT_REQUEST, (uri) => {
                return schema_contributor_1.schemaContributor.requestCustomSchemaContent(uri);
            });
        }, e => {
            // tslint:disable-next-line:no-console
            console.error(`yaml server start failed: ${e.message}`);
        });
        subscriptions.push(coc_nvim_1.services.registLanguageClient(client));
    });
}
exports.activate = activate;
function getSchemaAssociation(_context) {
    let associations = {};
    coc_nvim_1.extensions.all.forEach(extension => {
        let packageJSON = extension.packageJSON;
        if (packageJSON && packageJSON.contributes && packageJSON.contributes.yamlValidation) {
            let yamlValidation = packageJSON.contributes.yamlValidation;
            if (Array.isArray(yamlValidation)) {
                yamlValidation.forEach(jv => {
                    let { fileMatch, url } = jv;
                    if (fileMatch && url) {
                        if (url[0] === '.' && url[1] === '/') {
                            url = vscode_uri_1.default.file(path_1.default.join(extension.extensionPath, url)).toString();
                        }
                        if (fileMatch[0] === '%') {
                            fileMatch = fileMatch.replace(/%APP_SETTINGS_HOME%/, '/User');
                            fileMatch = fileMatch.replace(/%APP_WORKSPACES_HOME%/, '/Workspaces');
                        }
                        else if (fileMatch.charAt(0) !== '/' && !fileMatch.match(/\w+:\/\//)) {
                            fileMatch = '/' + fileMatch;
                        }
                        let association = associations[fileMatch];
                        if (!association) {
                            association = [];
                            associations[fileMatch] = association;
                        }
                        association.push(url);
                    }
                });
            }
        }
    });
    return associations;
}
//# sourceMappingURL=index.js.map